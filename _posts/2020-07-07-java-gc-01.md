---
layout: post
title: "GC(Garbage Collection)의 원리"
categories: [java]
comments: true
tags:
  - GC
  - Java
---

## Garbage Collection
### C/C++ 메모리 할당 
힙의 자유 메모리 블럭(free memory block)을 런타임 라이브러리(runtime library)가 유지 
- new/malloc으로 메모리 할당
    - 메모리 블럭 리스트를 검색, 요청된 크기의 메모리를 할당할 메모리 블럭을 찾음 
- delete/free로 메모리 해제
    - 해제된 메모리는 다시 사용 가능한 메모리 리스트에 삽입됨 

![c memory allocation](c-allocation.png)

단점 
- 메모리 할당에 소요되는 시간이 상대적으로 길다 
    - 할당/해제가 반복됨에 따라 메모리 사용 패턴은 조각남(사용 중/사용 가능한 메모리 블럭으로 쪼개어짐)
    - 조각난 메모리는 할당 시 자유 메모리 블럭 검색에 오버헤드를 가짐
- 해제 시 오버헤드 존재 
    - 인접한 자유 메모리 블럭 존재 시 병합

메모리 블럭의 할당과 해제가 잦아질수록, 메모리 블럭의 크기가 작을수록 메모리 조각 현상이 두드러진다. 메모리 할당은 연속적이어야 하기 때문에 힙의 크기가 충분함에도 불구하고 큰 메모리 블럭의 할당이 저해됨. 

### GC 작동 방식 
선형 메모리 할당, 사용하지 않는 메모리 블럭 제거 

선형 메모리 할당 
- 자유 메모리 블럭 리스트 사용 x
- 다음 메모리 할당을 위한 포인터만을 유지
- 메모리 할당 시 포인터 값 증가, 메모리를 초기화 
- 매우 빠름, 조각 발생 x -> 메모리 할당이 작고 잦을 때 효과적 

![GC memory allocation](gc-allocation.png)

메모리 해제 
- 특정 조건을 만족하는 상황에서 현재 수행중인 쓰레드들을 모두 중단, GC 쓰레드를 활성화
    - 힙 상에서 사용 중인 객체들의 그래프를 생성
    - 사용 중인 객체들의 위치를 재조정, 사용하지 않는 객체들을 힙에서 제거 
- 객체가 사용중임을 판별하기 위해 참조 그래프를 만듦 
    - 루트 참조 필요
        - 현재 각 쓰레드가 수행 중인 메서드의 로컬 변수(스택 변수)
        - CPU 레지스터 변수가 가지고 있는 참조
        - 현재 사용중인 각 타입(클래스)의 정적 필드
        - 전역 변수 
    - 루트 참조가 참조하는 객체, 그 객체가 참조하는 다른 객체 등을 참조 그래프에 추가해 그래프를 완성
    - 참조 그래프에 포함되지 않는(현재 사용중이지 않은) 모든 객체는 가비지 컬렉션의 대상

![GC operation](gc-operation.png)

> 요즘은 자유 메모리 블럭 방식보다 GC가 낫다. 해제가 바로 일어나지 않아 메모리 사용량은 더 많지만, 메모리가 비싸지 않기 때문. 

### GC의 최적화 기법 
**세대별 가비지 컬렉션**은 힙 상의 객체를 객체의 생존 시간을 기준으로 객체를 몇 세대로 구분해 가비지 컬렉션을 수행하는 것을 말함 
0세대 -> 1세대 -> 2세대 (살아남은 GC 횟수)
2세대의 객체들은 GC 수행 동안 계속 2세대에 남음 
기본 가비지 컬렉션은 0세대에 대해서만 이루어지며, 1세대와 2세대는 수행하지 않음
0세대에 집중적으로 가비지 컬렉션을 수행하면 성능과 효율이 올라가는 근거 
- 최근 생성된 객체일수록 생명주기가 짧음
- 오래된 객체일수록 생명주기가 긺
- 최근 생성된 객체들끼리는 서로 연관성이 높으며 비슷한 시점에서 자주 액세스됨
- 전체 힙보다 일부분의 힙을 가비지 컬렉션하는 것이 빠름

0세대가 사용할 메모리 공간이 줄어들고 1세대가 늘어남에 따라 특정 한계에 도달하면 0세대와 1세대에 대해 가비지 컬렉션을 수행함

GC 0: 0세대에 대해서만 수행

![GC0 operation](gc-0-operation.png)

GC 1: 0세대와 1세대에 대해 수행 

![GC1 operation](gc-1-operation.png)

GC 1 수행 이후에도 공간이 부족한 경우 2세대 가비지 컬렉션(풀 가비지 컬렉션) 수행 
-> 전체 힙에 대해 가비지 컬렉션 

### Finalizer와 가비지 컬렉션 
Finalizer가 수행되는 시점이 가비지 컬렉션이 수행되는 시점. 
GC는 가비지 컬렉션을 통해 객체를 제거할 때 해당 객체의 클래스가 Finalizer를 정의하고 있는지 검사. 
Finalizer를 갖는 클래스의 인스턴스가 제거되야 한다면 이 객체를 Freachable 큐에 삽입, Finalizer 수행을 위한 별도의 쓰레드를 실행 -> 큐에서 객체를 하나씩 꺼내 Finalizer 수행 

![GC finalizer](gc-finalizer.png)

- Finalizer가 실행되는 쓰레드는 애플리케이션 쓰레드가 아님
- Finalizer가 수행되는 순서나 시기는 예측 불가능

객체가 힙 상에서 제거되는 시점은 Finalizer 쓰레드가 객체의 Finalizer를 수행하고, 객체를 큐에서 제거한 다음에 발생하는 GC 시점이다. 
객체는 GC 동안 Finalizer 때문에 살아남았기 때문에 세대 증가

권장하지 않는 이유: Finalizer를 갖는 객체는 사용 중이 아니더라도 세대 승급 -> 힙에서 완전히 제거되는데 오래 걸림 

### 가비지 컬렉션의 고려사항들 
#### 장단점 
- 메모리 할당 속도 매우 빠름
- 해제는 C/C++의 메모리 해제 속도에 비해 느림
    - 참조 그래프 생성
    - 객체 위치 변경
    - 참조 값 변경 
- GC 발생 주기가 C/C++의 메모리 해제 함수 호출 빈도보다 낮아 전체적인 성능이 더 나쁘진 않음
- GC에 의해 관리되는 힙에 대해 개발자의 접근이 크게 제한됨 

#### 메모리 누수
메모리 누수란 할당된 메모리가 더 이상 사용되지 않음에도 불구하고 해제되지 않고 메모리 상에 남아 있음을 말한다. (C/C++의 경우, new/malloc 등을 통해 할당된 메모리가 delete/free 등으로 해제되지 않은 경우) 
- 메모리 자원 낭비 
- 메모리 부족 -> 성능 저하/시스템 다운

GC는 참조되지 않는 메모리가 해제되지 않는 경우는 발생 x, 하지만 불필요하게 길게 메모리를 점유할 수는 있음

#### 주의사항 
- 너무 잦은 객체 할당
- 너무 많은 참조
- 너무 많은 2세대 객체 
    - 생명주기가 매우 길고, 점유 영역은 잘 줄지 않음
    - Finalizer 사용 자제, 불필요한 참조 제거로 방지 
- Finalizer&Dispose 패턴
    - 객체의 사용이 완료되면 즉각 Dispose 메서드 호출 
    - Finalizer 호출 방지 

#### Reference 
닷넷 가비지 컬렉션 돌아보기