---
layout: post
title: "프로세스간 통신"
categories: [OS]
comments: true
tags:
  - OS
  - Process
---
## 프로세스간 통신 
운영체제 내에서 실행되는 병행 프로세스들은 독립적이거나 협력적인 프로세스들이다. 
- 독립적인 프로세스: 시스템에서 실행중인 다른 프로세스들에게 영향을 주거나 받지 않는다.
    - 다른 프로세스와 데이터를 공유하지 않음
- 협력적인 프로세스: 다른 프로세스들과 영향을 주고받는다. 
    - 자료를 공유 

프로세스 협력 허용 이유 
- 정보 공유
    - 정보(공유 파일 등)에 병행적으로 접근할 수 있는 환경 제공 
- 계산 가속화
    - 특정 태스크가 서브태스크로 나뉘어 서로 병렬적으로 실행되는 경우, 복수 개의 처리 요소(CPU, 입출력 채널 등)이 필수적임
- 모듈성
    - 시스템 기능을 별도의 프로세스나 스레드로 나누어 모듈식 형태로 시스템을 구성할 경우 
- 편의성
    - 한 사용자가 여러 태스크를 동시에 작업할 경우

협력적 프로세스들은 데이터와 정보를 교환할 수 있는 **프로세스간 통신**(interprocess communication, IPC) 기법을 필요로 한다. 

프로세스간 통신 모델에는 두 가지가 있다. 
- 공유 메모리 
- 메시지 전달

![interprocess communication method](interprocess-communication-method.png)

#### 공유 메모리 시스템 
일반적으로 운영체제는 한 프로세스가 다른 프로세스의 메모리에 접근하는 것을 금지한다. 하지만 공유 메모리 영역 사용을 위해서는 둘 이상의 프로세스가 이 제약 조건을 제거하는 것에 반드시 동의해야 한다. 

데이터의 형식과 위치는 이들 프로세스에 의해 결정되며, 프로세스들은 동시에 동일한 위치에 write 하지 않아야 한다. 

공유메모리 시스텝은 생산자-소비자 문제(한정 버퍼 문제)를 해결할 수 있다.
버퍼가 생산자와 소비자가 공유하는 메모리 영역에 존재해, 프로세스들이 병행으로 실행되며 버퍼에 정보를 채워 넣고 소모하게 된다. 
- 무한 버퍼(unbounded buffer): 버퍼의 크기에 실질적인 한계가 없다 
    - 소비자는 새로운 항목을 기다려야 할 수 있다. 
    - 생산자는 항상 새로운 항목을 생산할 수 있다. 
- 유한 버퍼(bounded buffer): 버퍼의 크기가 고정되어있다고 가정한다. 
    - 버퍼가 비어있으면 소비자는 대기해야 한다. 
    - 모든 버퍼가 채워져있으면 생산자가 대기해야 한다. 
    
#### 메시지 전달 시스템 
운영체제가 메시지 전달 설비를 통해 서로 협력하는 프로세스간의 통신 수단을 제공해 주는 방법이다.<br>통신하는 프로세스들이 네트워크에 의해 연결된 다른 컴퓨터들에 존재할 수 있는 분산 환경에서 유용하다. 최소 두 가지 연산(send, receive)를 제공한다. 

다음과 같은 방법들을 통해 하나의 통신 링크와 send/receive연산을 논리적으로 구현할 수 있다. 
- 직접 또는 간접 통신
- 동기식 또는 비동기식 통신
- 자동 또는 명시적 버퍼링 

##### 직접/간접 통신 
<u>직접 통신</u> 하에서, 통신을 원하는 각 프로세스는 다음과 같이 수신자 또는 송신자의 이름을 명시해야 한다. 
- send(P, message): 프로세스 P에게 메시지를 전송한다. 
- receive(Q, message): 프로세스 Q로부터 메시지를 수신한다. 

특징
- 통신을 원하는 모든 프로세스의 쌍 사이에 연결이 자동적으로 구축된다.<br>프로세스들은 통신하기 위해 서로 상대방의 신원(identity)만 알면 된다. 
- 연결은 정확히 두 프로세스 사이에만 연관된다. 
- 통신하는 프로세스들의 각 쌍 사이에는 정확하게 하나의 연결이 존재해야 한다. 

아래와 같이 주소 지정 시에 비대칭 형식을 사용할 수도 있다. 
- send(P, message)
- receive(id, message): 임의의 프로세스로부터 메시지를 수신한다.<br>변수 id는 통신을 발생시킨 프로세스의 이름으로 설정된다. 

단점 
- 프로세스를 정확히 지정함으로써 모듈화를 제한
    - 프로세스의 이름을 바꾸면 모든 다른 프로세스 지정부분의 검사가 필요

<u>간접 통신</u>에서 메시지들은 메일박스(mailbox) 또는 포트(port)로 송수신된다.<br>
메일박스는 추상적이며 메시지들이 넣어지거나 제거될 수 있는 객체라고 볼 수 있다. 각 메일박스는 고유의 식별자를 가진다. 

send, receive 연산은 다음과 같이 정의된다. 
- send(A, message): 메시지를 메일박스 A로 송신한다. 
- receive(A, message): 메시지를 메일박스 A로부터 수신한다. 

특징
- 한 쌍의 프로세스 사이의 연결은 이 프로세스들이 공유 메일박스를 가질 때만 구축된다. 
- 연결은 두 개 이상의 프로세스들과 연관될 수 있다. 
- 통신하고 있는 각 프로세스 사이에는 다수의 서로 다른 연결이 존재할 수 있고, 각 연결마다 하나의 메일박스가 할당된다. 

#### 동기식/비동기식 통신 
메시지 전달은 봉쇄형(blocking)이거나 비봉쇄형(nonblocking) 이다.
- 봉쇄형 송신: 송신 프로세스는 메시지가 수신 프로세스나 메일박스에 의해 수신될 때까지 기다린다. 
- 비봉쇄형 송신: 송신 프로세스가 메시지를 보내고 작업을 재시작한다. 
- 봉쇄형 수신: 메시지가 이용 가능할 때까지 수신 프로세스가 봉쇄된다. 
- 비봉쇄형 수신: 수신하는 프로세스가 유효한 메시지 또는 null을 받는다. 

#### 버퍼링(Buffering) 
통신 방법에 관계없이, 프로세스들에 의해 교환되는 메시지는 임시 큐에 들어있다.<br>큐 구현 방식은 다음과 같다.
- 무용량(zero capacity): 큐의 최대 길이가 0
    - 송신자는 수신자가 메시지를 수신할 때까지 기다려야 한다. 
- 유한 용량(bounded capacity): 큐는 유한한 길이 n을 가진다.
    - 최대 n개의 메시지가 들어있을 수 있다.
    - 새로운 메시지가 전송될 때 큐가 만원이 아니라면, 메시지는 큐에 놓이며 송신자는 대기하지 않고 실행을 계속한다. 
    - 큐가 만원이면 송신자는 큐 안에 가용한 공간이 생길 때까지 반드시 봉쇄되어야 한다. 
- 무한 용량(unbounded capacity): 큐는 잠재적으로 무한한 길이를 가진다. 
    - 메시지들이 무한히 큐 안에서 대기할 수 있다. 
    - 송신자는 봉쇄되지 않는다. 

무용량 버퍼는 버퍼링하지 않는 메시지 시스템이라고 불리며, 다른 경우들은 자동 버퍼링 메시지 시스템이라고 불린다. 
