---
layout: post
title: "CPU 스케줄링의 개념과 스케줄링 알고리즘"
categories: [OS]
comments: true
tags:
  - OS
  - Process
  - Scheduling
---

# CPU 스케줄링 
## 기본 개념
다중 프로그래밍(Multi-programming)의 목적: CPU 이용률을 최대화하기 위해 항상 실행 중인 프로세스를 가지는 것<br>
- 프로세스가 I/O 요청 때문에 대기할 때, CPU를 회수해 다른 프로세스에 할당함
- CPU가 아무 일도 하지 않는 상황이 발생하지 않도록 함 

### CPU-입출력 버스트 사이클(CPU-I/O Burst Cycle)
- CPU burst: CPU 명령을 실행하는 것
- I/O burst: I/O를 요청한 후 기다리는 것 

![CPU burst cycle](cpu-burst-cycle.jpg)

프로세스 실행은 CPU 버스트로 시작되며, CPU 버스트와 입출력 버스트의 사이클로 구성된다. 

CPU 버스트는 아래와 유사한 빈도수 곡선을 가진다. 

 ![CPU burst distribution](cpu-burst-distribution.png)

- I/O bound job : I/O 많이 사용, 다수의 짧은 CPU 버스트
- CPU bound job : CPU 많이 사용(계산 위주의 작업), 적고 긴 CPU 버스트

### CPU 스케줄러(CPU Scheduler)
CPU가 유휴 상태가 될 때마다 운영체제는 준비완료 큐에 있는 프로세스들 중 실행될 프로세스를 선택해야 한다.<br>
단기 스케줄러는 실행 준비가 되어 있는 메모리 내의 프로세스들 중 하나를 선택해 CPU를 할당한다. 

준비완료 큐는 FIFO 큐, 우선순위 큐, 트리 또는 연결 리스트로 구현할 수 있다.<br>
큐에 있는 레코드들은 일반적으로 프로세스 제어 블록(PCB)들이다. 

### 선점 스케줄링(Preemptive Scheduling)
**선점 스케줄링**: 현 실행 프로세스로부터 강제로 CPU를 회수하는 것
- 공유 자료에 접근하는 경우, 비용을 유발함
    - 두개 이상의 프로세스가 공유 자료에 접근할 경우를 대비해 접근을 조정할 새로운 매커니즘이 필요함
- 운영체제 커널 설계에 영향을 줌
    - 프로세스의 진입점에서 인터럽트를 불능화하고 출구에서 다시 가능화
    - 문맥 교환 도중 인터럽트가 발생하면, 동시 사용 가능한 코드 부분에서 입력을 잃어버리거나 출력이 겹칠 수 있다.

**비선점 스케줄링**: 프로세스가 자원을 할당 받았을 경우, 자원을 스스로 반납할 때까지 계속 그 자원을 사용하도록 허용하는 정책 
- 프로세스가 종료 또는 대기 상태로 전환해 CPU를 방출할 때까지 CPU를 점유함

CPU 스케줄링은 다음의 네 가지 상황 하에 발생할 수 있다. 
- 한 프로세스가 실행 상태에서 대기 상태로 전환될 때
    - 입출력 요청 또는 자식 프로세스들 중 하나가 종료되기를 기다리기 위해 wait를 호출할 경우
- 프로세스가 실행 상태에서 준비완료 상태로 전환될 때 
    - 인터럽트가 발생할 때
- 프로세스가 대기 상태에서 준비완료 상태로 전환될 때
    - 입출력 종료 시 
- 프로세스가 종료할 때

첫번째와 네번째의 경우, 실행을 위해 새로운 프로세스가 반드시 선택되어야 함 -> 비선점
두번째와 세번째 -> 선점 

### 디스패처(Dispatcher)
디스패처는 CPU 제어를 단기 스케줄러가 선택한 프로세스에게 주는 모듈이며, 다음과 같은 작업을 포함한다. 
- 문맥 교환
- 사용자 모드로 전환
- 프로그램을 다시 시작하기 위해 사용자 프로그램의 적절한 위치로 이동(jump)하는 일

디스패처는 모든 프로세스의 문맥 교환 시 호출되므로, 가능한 한 빨라야 한다.

디스패치 지연(dispatch latency): 디스패처가 하나의 프로세스를 중단시키고 다른 프로세스를 실행시키는 데까지 소요되는 시간

## 스케줄링 기준(Scheduling Criteria)
다음은 CPU 스케줄링 알고리즘 비교를 위한 선택 기준들이다. 
- CPU 이용률(utilization)
- 처리량(throughput)
- 총처리 시간(turnaround time)
- 대기 시간(waiting time)
- 응답 시간(response time)

## 스케줄링 알고리즘(Scheduling Algorithm)
### 선입 선처리 스케줄링(First-COme, First-SErved Scheduling)
가장 간단한 스케줄링 알고리즘으로, CPU를 먼저 요청하는 프로세스가 CPU를 먼저 할당받는다.<br>
선입 선처리 정책의 구현은 FIFO 큐로 쉽게 관리할 수 있다.

- 프로세스의 종료 시간을 비교적 정확하게 예측할 수 있다. 
- 평균 대기 시간이 길 수 있다. 
- 프로세스 버스트 시간이 크게 변할 경우 평균 대기시간도 크게 변할 수 있다. 
- 호위 효과(convoy effect)가 발생할 수 있다. 
    - 하나의 긴 프로세스가 먼저 CPU를 할당받을 경우, 모든 다른 프로세스들이 대기해야 함
    - 짧은 프로세스들이 먼저 처리되도록 허용될 때보다 CPU와 장치 이용률이 저하됨
- 비선점형이다.

### 최단 작업 우선 스케줄링(Shortest-Job-First Scheduling)
CPU 버스트가 가장 작은 프로세스부터 자원을 할당해, 평균 대기시간을 최소로 만드는 걸 최적으로 한다.<br>
두 프로세스의 CPU 버스트가 같다면, 선입 선처리 스케줄링을 적용해 순위를 정한다.

- 잔여시간이 최소인 프로세스가 우선이다. 
- 기아 상태가 발생할 수 있다. 
    - 요구 시간이 긴 프로세스는 요구 시간이 짧은 프로세스에게 항상 밀리게 되므로
- 대기 중인 프로세스의 CPU 버스트를 알기 어렵다. 
    - 단기 스케줄링 수준에서는 구현할 수 없다.
- 선점형이거나 비선점형일 수 있다. 
    - 선점형일 경우, 현재 실행되고 있는 프로세스의 남은 시간보다 더 짧은 CPU 버스트가 있으면 그 프로세스에게 양보한다. 

### 우선순위 스케줄링(Priority Scheduling)
가장 높은 우선순위를 가진 프로세스에게 CPU가 할당되며, 우선순위가 같은 프로세스들은 선입 선처리 순서로 스케줄된다. 

- 무기한 봉쇄(indefinite blocking)/기아 상태가 발생할 수 있다. 
    - 실행 준비는 되어있지만 우선순위가 낮아 무기한 대기할 수 있다. 
    - **Aging**으로 해결할 수 있다. 
        - 오랜 시간 대기하는 프로세스들의 우선순위를 점진적으로 높여주는 방식
- 선점형이거나 비선점형일 수 있다. 
    - 선점형일 경우, 새로 도착한 프로세스의 우선순위가 현재 실행중인 프로세스의 우선순위보다 높다면 CPU를 선점한다. 
    - 비선점형일 경우, 더 높은 우선순위의 프로세스가 도착하면 준비완료 큐의 Head에 넣는다. 

### 라운드 로빈 스케줄링(Round-Robin Scheduling)
시간 할당량(time quantum) 또는 시간 조각(time slice)라는 작은 단위의 시간을 정의해, 준비완료 큐를 돌면서 한 프로세스씩 시간 할당량 동안 CPU를 할당한다. 

준비완료 큐는 원형 큐 형태로, 선입 선출 구조이다. Head 프로세스를 선택해 한 번의 시간 할당량 이후에 인터럽트를 걸도록 타이머를 설정한 후, 프로세스를 디스패치(dispatch)한다. 

프로세스의 CPU 버스트가 한 번의 시간 할당량보다 작을 경우, 프로세스는 CPU를 자발적으로 방출한다.<br>
반대의 경우, 타이머가 만료되면 인터럽트가 발생해 문맥교환이 일어나고, 실행 중인 프로세스는 준비완료 큐의 꼬리에 넣어진다. 

- 시분할 시스템을 위해 설계됨
- 선점형이다. 
    - 한 번의 시간 할당량이 지나면, 프로세스는 선점된다. 
- 성능과 총처리 시간이 시간 할당량의 크기에 많은 영향을 받는다. 
    - 시간 할당량이 너무 크다면, 선입 선처리 정책과 같다. 
        - 평균 대기 시간이 길어짐
    - 너무 작을 경우, 문맥 교환이 잦아져 CPU 이용률은 낮아진다(문맥 교환 CPU는 아무 일도 하지 못하기 때문에).

### 다단계 큐 스케줄링(Multilevel Queue Scheduling)
다단계 큐 스케줄링은 프로세스들이 쉽게 분류될 수 있을 때 사용한다.

![multilevel queue scheduling](multilevel-queue-scheduling.png)

준비완료 큐를 다수의 별도 큐로 분류하고, 프로세스들을 메모리 크기, 우선순위, 유형 등의 프로세스 특성에 따라 한 개의 큐에 영구적으로 할당한다.<br> 각 큐는 자신의 스케줄링 알고리즘을 갖고 있다.

큐와 큐 사이의 스케줄링도 있어야 하며, 일반적으로 고정 우선순위의 선점형 스케줄링으로 구현된다. 

- 한 번 큐에 들어가면 프로세스는 다른 큐로 이동되거나 변경되는 것이 불가능
    - 스케줄링 오버헤드가 적음
- 고정된 우선순위의 선점식 스케줄링
    - 전면작업 큐는 후면작업 큐보다 항상 높은 우선순위를 가진다. 
    - 실행 중인 프로세스보다 상위 단계 큐의 프로세스가 들어오면 CPU를 선점한다. 
- 큐들 사이에 시간을 나누어 사용하는 것도 가능
    - CPU 시간의 일정량을 받아 자기 큐의 프로세스들을 스케줄링

### 다단계 피드백 큐 스케줄링(Multilevel Feedback Queue Scheduling)
다단계 피드백 큐 스케줄링 알고리즘에서는 프로세스가 큐 사이를 이동하는 것을 허용한다.<br>

프로세스들은 CPU 버스트 성격에 따라 구분된다. 어떤 프로세스가 CPU 시간을 너무 많이 사용하면, 해당 프로세스는 낮은 우선순위의 큐로 이동된다. 

마찬가지로 낮은 우선순위의 큐에서 너무 오래 대기하는 프로세스는 높은 우선순위의 큐로 이동할 수 있다. 

다단계 피드백 큐 스케줄러는 다음의 매개변수에 의해 정의된다. 
- 큐의 수
- 각 큐의 스케줄링 알고리즘 
- 한 프로세스를 높은 우선순위 큐로 올려주는 시기를 결정하는 방법
- 한 프로세스를 낮은 우선순위 큐로 강등시키는 시기를 결정하는 방법 
- 프로세스가 서비스를 필요로 할 때 프로세스가 들어갈 큐를 결정하는 방법 

**작동 방식**

![multilevel feedback queue](multilevel-feedback-queue.jpg)

모든 프로세스들은 처음에 큐 0으로 들어가 8의 시간 할당량을 가진다. 시간 할당량 동안 완료되지 못한 프로세스는 2배의 시간 할당량을 가진 큐 1로 들어가고, 마찬가지로 완료되지 못하면 큐 2로 들어가게 된다. 마지막 큐는 보통의 백그라운드 프로세스가 그랬듯 선입 선처리 구조로 처리된다. 

- 총처리 시간에 최적화됨
    - CPU 버스트를 통해 우선순위를 예측하고 변경함
    - 더 짧은 프로세스가 먼저 실행되므로 총처리 시간의 평균을 줄일 수 있음
- 기아 상태를 예방
    - 일종의 aging(오래 대기하는 프로세스의 우선순위를 높임)

#### Reference
다단계 피드백 큐 스케줄링 - <https://jhnyang.tistory.com/156><br>