## Interface 
객체의 사용 방법을 정의한 타입 
- 개발자 사이의 코드 규약을 정함
- 여러 구현체에서 공통적인 부분을 추상화(다형성)

자바 인터페이스는 기본적으로 추상메서드의 모음이다. 추상메서드는 아래와 같이 구현부가 없는 메서드를 말한다.

```java
public interface Walkable {
  void walk();
}
```

구현부가 없으므로 인터페이스를 만든다면 반드시 구현하는 클래스를 만들어야 하며, 인터페이스를 구현하기로 한 클래스는 반드시 인터페이스에 명시되어 있는 추상메서드들을 모두 구현해야 한다. 만약 이를 구현하지 않으면 컴파일 에러가 발생한다.

```java
public class Dog implements Walkable {
  // ...
  @Override
  public void walk() {
    // ...
  }
}
```

인터페이스는 구현과 상속을 모두 할 수 있다.

- 인터페이스를 사용하는 구체 클래스는 해당 인터페이스를 구현해야한다.
- 인터페이스 사이에는 상속을 할 수 있다.
- 인터페이스 내에 디폴트 메서드, 추상 메서드, 정적 메서드 모두 존재 가능

디폴트 메서드의 목적은 기존 인터페이스 기능을 확장하며, 구현체에 공통적으로 들어갈 기능(코드)를 디폴트 메서드 내부에 작성함으로써 반복되는 코드의 작성을 줄여줍니다. 
특징은 default 키워드를 반드시 붙여줘야합니다.따라서 나중에 메서드의 기능이 추가되었을때 구현체에서 고칠 필요가 없으며 인터페이스의 디폴트 메서드 내부 코드만 수정하면 된다. 

## 인터페이스와 추상클래스의 공통점, 차이점 

#### 공통점 
- 추상클래스와 인터페이스 모두 **선언만 있고 구현 내용은 없는 클래스**다. 
- 상속받는 클래스나 구현하는 인터페이스 안에 있는 **추상 메서드를 구현**하도록 강제함

#### 차이점
추상 클래스는 상속을 통해 기능을 이용하고 확장시키는 것을 목적으로 함. 
인터페이스는 구현을 강제해 구현 객체의 같은 동작을 보장함. (모든 구현체에 특정한 메서드가 반드시 존재하므로)

추상클래스 
- **여러 클래스들의 공통점을 찾아 추상화시켜 사용하는 것이 목표**
- 추상클래스는 추상메서드가 없어도 무방
- 다중상속 안됨
- 멤버 변수 존재 가능

인터페이스
- **구현 객체가 같은 동작을 한다는 것을 보장**
- 다중상속 지원(구현체에 여러 인터페이스를 구현 가능)
- 구현하는 모든 클래스에 대해 특정한 메서드가 반드시 존재하도록 강제하는 역할

### ref 
<https://jeong-pro.tistory.com/82>
<https://medium.com/webeveloper/%EC%9E%90%EB%B0%94-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EC%99%80-%EC%B6%94%EC%83%81%ED%81%B4%EB%9E%98%EC%8A%A4-6eecbe5d6350>
<https://brunch.co.kr/@kd4/6>

## Java Runtime Data Area

![java runtime data area](java-runtime-data-area.png)

1. Method Area
    - 클래스 멤버 변수 이름, 데이터 타입, 접근 제어자 등의 필드 정보
    - 메서드 이름, 리턴 타입, 파라미터, 접근 제어자 등 메서드 정보
    - Type정보(Interface인지 class인지), Constant Pool(상수 풀 : 문자 상수, 타입, 필드, 객체 참조가 저장됨), static 변수, final class 변수
2. Heap Area
    - new 키워드로 생성된 객체와 배열이 생성되는 영역이다.

메소드 영역에 로드된 클래스만 생성이 가능하고 Garbage Collector가 참조되지 않는 메모리를 확인하고 제거하는 영역이다.

3. Stack Area
지역 변수, 파라미터, 리턴 값, 연산에 사용되는 임시 값등이 생성되는 영역이다.

int a = 10; 이라는 소스를 작성했다면 정수값이 할당될 수 있는 메모리공간을 a라고 잡아두고 그 메모리 영역에 값이 10이 들어간다. 즉, 스택에 메모리에 이름이 a라고 붙여주고 값이 10인 메모리 공간을 만든다.

클래스 Person p = new Person(); 이라는 소스를 작성했다면 Person p는 스택 영역에 생성되고 new로 생성된 Person 클래스의 인스턴스는 힙 영역에 생성된다.

그리고 스택영역에 생성된 p의 값으로 힙 영역의 주소값을 가지고 있다. 즉, 스택 영역에 생성된 p가 힙 영역에 생성된 객체를 가리키고(참조하고) 있는 것이다.

메소드를 호출할 때마다 개별적으로 스택이 생성된다.
4. PC Register Area
Thread(쓰레드)가 생성될 때마다 생성되는 영역으로 Program Counter 즉, 현재 쓰레드가 실행되는 부분의 주소와 명령을 저장하고 있는 영역이다. (*CPU의 레지스터와 다름)

이것을 이용해서 쓰레드를 돌아가면서 수행할 수 있게 한다.
5. Native Method Area
자바 외 언어로 작성된 네이티브 코드를 위한 메모리 영역이다.

보통 C/C++등의 코드를 수행하기 위한 스택이다. (JNI)

쓰레드가 생성되었을 때 기준으로

1,2번인 메소드 영역과 힙 영역을 모든 쓰레드가 공유하고,

3,4,5번인 스택 영역과 PC 레지스터, Native method stack은 각각의 쓰레드마다 생성되고 공유되지 않는다.

ref: https://jeong-pro.tistory.com/148
