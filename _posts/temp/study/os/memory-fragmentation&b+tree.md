index 사용 시 cardinality


'//단편화 
// b+ tree 차수 (degree) - 필요한 이유, 
// 인덱스 다시 이해 
// 디스크 접근 시간 

- 데이터의 분산도(Cardinality)가 낮은 열에는 인덱스를 사용하면 안됨  //성별 , 학년, 
    - 하나의 열에 중복되는 데이터가 많을 경우 

// 중복되는 값을 index로 할 경우 어떻게 찾는지

>index range scan / full scan 
찾아야 하는 데이터가 전체 데이터의 5%~20%를 넘어서는 경우에는 table full scan이 유리할 수 있다. 
인덱스 테이블에서 찾고 또 그걸 테이블에서 찾는것보다 그냥 바로 table에 access해서 찾는게 빠를 수 있기 떄문 

예시) 10000개 중 10 %를 찾는다 칠때 (1000개)
하나 인덱스 당 5번 탐색 * 1000개 -> 그래도 5000개밖에 안됨 
10000개보다 적은데 왜  full scan이 더 유리할까 
-> disk 접근 시간 때문 

디스크 접근 시간 = 탐색 시간+회전 지연시간+전송시간 
-> 회전 전송시간이 제일 큼(물리적으로 DC모터 돌려서 디스크 이동시켜야 하기 때문)

((탐색 시간 = 5) * 회전지연 + 전송)*1000 > 10000개 탐색시간 
(index 테이블이 디스크에 존재할 경우(인메모리 말고))


b+ 트리는 높이가 b트리보다 낮게 구성됨 -> 검색시간, 디스크 접근 횟수가 줄음 

--- 
## 단편화(Fragmentation)
단편화: 기억 장치의 빈 공간 또는 자료가 여러 개의 조각으로 나뉘는 현상
- 사용 가능한 메모리가 충분하지만 할당할 수 없는 상태
- 기억 장치의 사용 가능 공간을 줄임
- 읽기와 쓰기 수행 속도를 늦춤
    - 쓰기 수행 속도 -> 총 가용 공간이 충분하더라도, 데이터를 넣을 공간을 찾는데 오래 걸릴 수 있음(연속된 공간이어야 하므로)

잦은 동적할당->메모리 단편화를 발생시킴 

![memory fragmentation](memory-fragmentation.gif)

#### 내부 단편화(Internal Fragmentation)
메모리를 할당할 때 프로세스가 필요한 양보다 더 큰 메모리가 할당되어서 프로세스에서 사용하는 메모리 공간이 낭비 되는 상황
- 해당 자원 내에서 사용하지 않는 부분이 생김

**내부 단편화의 종류**
- 개체 크기를 CPU 캐시Cache 라인에 맞추기 위해서 빈 공간을 덧붙이는 패딩(Padding).
- 자원 할당에 필요한 추가 정보를 기록하기 위한 여분의 공간을 할당하는 경우.
- 외부 단편화를 피하기 위해서 사용하는 할당 알고리즘 때문에 어쩔 수 없이 내부 단편화가 생기는 경우.

#### 외부 단편화(External Fragmentation)
메모리가 할당되고 해제되는 작업이 반복될 때 작은 메모리가 중간중간 존재하게 된다. 이 때 중간중간에 생긴 사용하지 않는 메모리가 많이 존재해서 총 메모리 공간은 충분하지만 실제로 할당할 수 없는 상황(메모리가 연속적이지 않아 사용 불가)

### 메모리 단편화 해결 방법
#### 페이징(Paging) 기법

#### 세그멘테이션(Segmentation) 기법

#### 메모리 풀(Memory Pool)

#### Reference
<https://jeong-pro.tistory.com/91><br>
