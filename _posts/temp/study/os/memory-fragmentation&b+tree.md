index 사용 시 cardinality


'//단편화 
// b+ tree 차수 (degree) - 필요한 이유, 
// 인덱스 다시 이해 
// 디스크 접근 시간 

- 데이터의 분산도(Cardinality)가 낮은 열에는 인덱스를 사용하면 안됨  //성별 , 학년, 
    - 하나의 열에 중복되는 데이터가 많을 경우 

// 중복되는 값을 index로 할 경우 어떻게 찾는지

>index range scan / full scan 
찾아야 하는 데이터가 전체 데이터의 5%~20%를 넘어서는 경우에는 table full scan이 유리할 수 있다. 
인덱스 테이블에서 찾고 또 그걸 테이블에서 찾는것보다 그냥 바로 table에 access해서 찾는게 빠를 수 있기 떄문 

예시) 10000개 중 10 %를 찾는다 칠때 (1000개)
하나 인덱스 당 5번 탐색 * 1000개 -> 그래도 5000개밖에 안됨 
10000개보다 적은데 왜  full scan이 더 유리할까 
-> disk 접근 시간 때문 

디스크 접근 시간 = 탐색 시간+회전 지연시간+전송시간 
-> 회전 전송시간이 제일 큼(물리적으로 DC모터 돌려서 디스크 이동시켜야 하기 때문)

((탐색 시간 = 5) * 회전지연 + 전송)*1000 > 10000개 탐색시간 
(index 테이블이 디스크에 존재할 경우(인메모리 말고))


b+ 트리는 높이가 b트리보다 낮게 구성됨 -> 검색시간, 디스크 접근 횟수가 줄음 

--- 

## 단편화(Fragmentation)
단편화: 기억 장치의 빈 공간 또는 자료가 여러 개의 조각으로 나뉘는 현상
- Contiguous memory allocation의 단점
    - 메모리를 연속적으로 할당해야 하는데, 크기에 맞는 연속된 빈 공간이 없을 때 발생 
- 사용 가능한 메모리가 충분하지만 할당할 수 없는 상태
- 잦은 동적할당으로 인해 발생 
- 읽기와 쓰기 수행 속도를 늦춤 //?
    - 쓰기 수행 속도 -> 총 가용 공간이 충분하더라도, 데이터를 넣을 공간을 찾는데 오래 걸릴 수 있음(연속된 공간이어야 하므로)

잦은 동적할당->메모리 단편화를 발생시킴 

![memory fragmentation](memory-fragmentation.gif)

#### 내부 단편화(Internal Fragmentation)
메모리를 할당할 때 프로세스가 필요한 양보다 더 큰 메모리가 할당되어서 프로세스에서 사용하는 메모리 공간이 낭비 되는 상황
- 해당 자원 내에서 사용하지 않는 부분이 생김

// 분할된 크기 기준으로 정수배만큼 할당할 수 있는데 딱 못맞춰서 

요구되는 크기가 할당 단위로 딱 나누어지지 않을 때 내부 단편화 발생 
-> tradeoff) 할당 단위가 일정하므로 빈 공간 크기를 계속 계산하면서 찾지 않아도 됨
메모리 쪼금 남는게 그것보다 이득
그래도 외부 단편화는 발생 -> 페이징같이 분할해서 넣음
그럼 남는 공간 크기 일일이 계산할 필요없이ㅣ 그냥 숫자만 맞춰넣음될거같다 

#### 외부 단편화(External Fragmentation)
메모리가 할당되고 해제되는 작업이 반복될 때 작은 메모리가 중간중간 존재하게 된다. 이 때 중간중간에 생긴 사용하지 않는 메모리가 많이 존재해서 총 메모리 공간은 충분하지만 실제로 할당할 수 없는 상황(메모리가 연속적이지 않아 사용 불가)

// compaction으로 해결 불가능한 이유 
프로세스가 들어갈 크기를 만들기 위해 다른 프로세스들을 옮긴다. 
-> 임시로 하드디스크 등에 복사해놔야 하는데, 하드디스크 접근 시간이 매우 느려서 불가능
// 옮길 동안 서비스 중단됨 

### 메모리 단편화 해결 방법
#### 페이징(Paging) 기법
- 페이징: 논리주소의 고정된 페이지(Page)라고 불리는 블록들로 분할 관리하는 기법
- 각각의 페이지는 물리 메모리의 프레임과 맵핑
- 페이지를 가리키는 논리주소에서 프레임을 가리키는 물리주소로 변환

mapping 과정을 위해 paging table 필요 
연속적이지 않은 공간도 활용 가능-> 외부 단편화 해결 
페이지를 완벽하게 꽉 채우는 게 아니므로 내부 단편화는 남아있을수도 

// 페이지 단위를 작게 하면 내부 단편화도 해결할 수 있겠지만 매핑 과정은 늘어나므로 효율 떨어질 수 있음 

페이지 테이블은 캐시에 넣음
cpu 레지스터 -> 속도는 빠르지만 공간이 부족
메인 메모리 -> 공간은 많지만 속도가 느림

#### 세그멘테이션(Segmentation) 기법

#### 메모리 풀(Memory Pool)

#### Reference
<https://jeong-pro.tistory.com/91><br>
<https://jhnyang.tistory.com/264><br> 
