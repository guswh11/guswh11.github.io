## 고전적인 동기화 문제들
아래는 병행 제어로 일어나는 문제에 대한 예시이다. 새로 제안된 동기화 방법들을 테스트하는 데 사용된다. 

### 유한 버퍼 문제(The Bounded-Buffer Problem)
- 생산된 데이터는 버퍼에 저장됨
- 현실 시스템에서 버퍼의 크기는 한정되어 있음
- 생산자는 버퍼가 가득 차면 더 넣을 수 없음
- 소비자는 버퍼가 비어있으면 뺄 수 없음
- 생산과 소비의 속도 차이 존재

**유한 버퍼 문제의 원인**
유한 버퍼 문제는 상호배제가 잘 지켜지지 않아 발생한다. 
- 공통변수 count(), buf[]에 대한 동시 접근 진행
- 공통변수 업데이트 구간(임계구역)에 대한 동시 진입이 진행

**예시**

![bounded-buffer problem ex1](bounded-buffer-ex-1.png)

1. 소비자가 if(count==0)을 실행하자마자 스케쥴링이 일어나서 생산자가 cpu사용권을 획득했다.
2. 생산자는 아이템을 생산하고 공유변수인 count를1증가시킨후에 자고 있지도 않은 소비자를 깨운다.
3. 아무일도 일어나지 않은 상태로 다시 스케쥴링이 일어나서 소비자가 sleep()을 실행해서 잠에 든다.
4. 그리고 다시 스케쥴링이 일어나서 생산자 프로세스가 실행되면 생산자는 count값이 2부터 시작해서 계속 증가하게 된다.
5. 생산자는 버퍼가 꽉찰때까지 (N이 100이 될때까지) 계속 생산하다가 count == N을 만족해서 잠이든다.
6. 결국에는 생산자 소비자가 둘다 잠에 든다는 문제가 발생한다.

![bounded-buffer problem ex2](bounded-buffer-ex-2.png)

**해결 방법** 
- 임계구역에 대한 동시 접근 방지(상호배타)
- 세마포를 사용한 상호배타 (mutual exclusion)
- 세마포: mutex.value = 1(# of permit)

**생산자 프로세스의 구조**

```c
do {
    ...
    // produce an item in nextp
    ...
    wait(empty);
    wait(mutex);
    ...
    // add nextp to buffer
    ...
    signal(mutex);
    signal(full);
} while(true);
```

**소비자 프로세스의 구조**

```c
do {
    wait(full); 
    wait(mutex);
    ...
    // remove an item from buffer to nextc
    ...
    signal(mutex);
    signal(empty);
    ...
    // consume the item in nextc
    ...
} while(true); 
```

생산자가 소비자를 위해 꽉 찬 버퍼를 생산해내고, 소비자는 생산자를 위해 비어 있는 버퍼를 생산해낸다. 

### Readers-Writers 문제
주로 공통된 데이터베이스에 접근할 때 발생한다. 
데이터베이스의 경우 writer에게는 배타적 접근을 보장해야 하지만, 동시에 여러 reader가 접근하는 것은 허용되어야 한다. 

**문제의 변형**
- The first R/W problem(readers-preference): 항상 reader 에게 우선권을 준다.
- The second R/W problem(writer-preference): writer에게 우선권을 준다.
- The third R/W problem: 우선권을 아무에게도 주지 않는것

문제의 해결책으로, reader-writer 락이 존재한다. Reader-writer 락은 획득할 때 읽기/쓰기 모드를 지정해야 한다.

Reader-writer 락은 다음과 같은 상황에서 유용하다.
- 공유 데이터를 읽기만 하는 프로세스와 쓰기만 하는 프로세스를 식별하기 쉬울 때
- writer보다 reader가 많을 때
    - 일반적으로 reader-writer 락을 설정하는 것이 세마포어나 상호 배제 락 설정보다 오버헤드가 큼
    - 오버헤드를 여러 reader를 접근하게 해 병행성을 높이는 것으로 상쇄함 

### 식사하는 철학자들 문제(The-Dining-Philosophers Problem)

철학자는 자신의 양 옆에 있는 젓가락을 모두 집거나, 둘 중 하나의 젓가락만 집을 수 있다. 이미 옆 사람 손에 들어간 젓가락은 집을 수 없으며, 젓가락을 집으면 놓지 않고 식사를 한다. 식사를 마치면 젓가락을 놓고 다시 생각한다. 

## 원자적 트랜잭션(Atomic Transactions)
### 시스템 모델(System Model)
트랜잭션: 하나의 논리적인 기능을 실행하는 명령어의 집합
- 완료(commit): 트랜잭션이 성공적으로 실행됨
- 철회(abort): 논리적인 문제나 시스템 고장 때문에 실행이 중간에 끝남

원자성을 보장하기 위해, 철회된 트랜잭션에 의해 접근된 데이터의 상태는 트랜잭션 시작 이전의 값들로 복원시켜 주어야 한다. 
-> 트랜잭션이 **롤백(roll back)**된다고 표현

**하드웨어 장치들의 데이터 저장 방법**
- 휘발성(volatile) 저장장치
    - 시스템이 고장나면 저장된 정보는 사라짐
    - 속도가 매우 빠름
- 비휘발성(nonvolatile) 저장장치
    - 시스템이 고장나더라도 내부의 정보는 보존됨
    - 휘발성 저장장치보다 수십, 수백 배 이상 느림
        - 물리적인 동작을 거쳐 액세스하기 때문
- 안전(stable) 저장장치
    - 모든 실패에도 살아남는 이론적인 형태의 저장장치
    - 이는 서로 다른 비휘발성 매체에 여러 사본을 유지함으로써 이루어진다.

### 로그 기반 복구
원자성을 보장해 주는 한 방법은 트랜잭션에 의한 모든 데이터 변경 내역을 안전 저장장치에 기록해 놓는 것이다. **로그 우선 쓰기(write-ahead logging)**방식에서 시스템은 안전 저장장치에 **로그(log)**라고 불리는 자료구조를 유지한다. 

각 로그 레코드는 트랜잭션의 하나의 쓰기 연산을 설명하고, 아래와 같은 필드를 가진다. 
- 트랜잭션 이름
- 데이터 항목 이름
- 이전 값
- 새 값

**로그 레코드**
- \<T starts>: 트랜잭션 T가 시작되기 전에 쓰임
- \<T commits>: T가 완료되면 쓰임 

복구 알고리즘은 두 개의 프로시저를 사용한다. 
- undo(T): T가 갱신한 모든 데이터 항목의 값들을 T가 시작되기 이전으로 되돌린다. 
- redo(T): T가 갱신한 데이터 항목에 새로운 값들을 넣는다. 

undo와 redo 연산은 반드시 idempotent 해야(연산을 여러 번 실행해도 한번 실행한 것과 결과가 같아야) 한다.

트랜잭션 분류 작업은 다음과 같이 이루어진다. 
- 로그에 <T starts> 레코드는 있지만 <T commits> 레코드가 없다면 T는 undo 된다. 
- 로그에 <T starts>와 <T commits>라는 두 개의 레코드가 다 있다면, T는 redo 된다. 

**로그 기반 복구 방식의 단점**
- 검색 시간에 시간이 너무 많이 소모된다. 
- redo 대상 트랜잭션들은 이미 데이터 항목도 갱신된 상태인데, 중복해서 redo 하는 것은 시스템 복구 시간을 늘린다. 

### 검사점(Checkpoints)
검사전 기반 복구 시스템은 전과 마찬가지로 로그 우선 쓰기(write-ahead log)를 유지한다. 이에 더해 시스템은 주기적으로 다음 순서와 같은 작업들로 구성된 **검사점**을 실행한다. 
1. 그 때까지 휘발성 저장장치(주기억장치)에 있던 로그 레코드들을 모두 안전 저장장치로 출력한다. 
2. 그 때까지 휘발성 저장장치에서 변경된 모든 데이터 항목들을 안전 저장장치로 출력한다. 
3. <checkpoint>라는 로그 레코드를 안전 저장장치로 출력한다. 

검사점 이전에 완료된 트랜잭션에서 실행한 모든 변경은 안전장치에 이미 쓰였다. 따라서 시스템 복구 시 검사전 이전의 트랜잭션에 대한 redo는 할 필요가 없다. 

시스템 고장이 일어나면 복구 루틴은 가장 최근 검사점 직전의 트랜잭션을 찾기 위해 로그를 조사한다.<br>
해당 트랜잭션과 그 이후의 모든 트랜잭션들의 집합을 T라 할때, T에 대해서만 redo와 undo를 적용하면 된다. 
- <T commits>가 로그에 기록되어 있으면, redo(T)를 실행시킨다. 
- <T commits>가 로그에 기록되어 있지 않으면, undo(T)를 실행시킨다. 

### 동시 실행 원자적 트랜잭션(Concurrent Atomic Transactions)
다수의 트랜잭션들이 동시에 활성화되는 경우
- 결과가 모든 트랜잭션들을 어떤 임의의 순서에 따라 순차적으로 실행시킨 것과 같아야 함(**직렬가능성**)
- 각 트랜잭션들이 임계 영역 내에서 실행되어야 함
    - 모든 트랜잭션들이 뮤텍스(mutex)를 공유
    - 시작 - wait(mutex), 완료/철회 - signal(mutex)

아래의 동시성 알고리즘들은 직렬가능성을 보장하면서 트랜잭션들의 실행을 중첩시킬 수 있다. 

#### 직렬가능성(Serializability)
스케줄(schedule): 트랜잭션들의 실행 순서
- 직렬 스케줄(serial schedule): 각 트랜잭션들이 원자적으로 실행되는 스케줄
    - 각 트랜잭션에 속한 명령어들이 연속된 한 집합으로 나타남 
    - n개의 트랜잭션 -> n!개의 유효한 직렬 트랜잭션 
    - 올바르다(임의의 순서로 원자적으로 실행시키는 것과 동등함)
- 비직렬 스케줄(nonserial schedule): 트랜잭션이 중첩되어 실행

충돌 직렬가능(conflict serializable): 비직렬 스케줄에 있는 비충돌 연산들을 서로 swap 시켜줌으로써 직렬 스케줄로 변환시킬 수 있음 

#### 락킹 프로토콜(Locking Protocol)

#### 타임스탬프 기반 프로토콜(Timestamp-Based Protocols)

#### Reference
유한 버퍼 문제 - <https://simsimjae.tistory.com/70>, <https://velog.io/@zehye/%EC%A0%84%ED%86%B5%EC%A0%81-%EB%8F%99%EA%B8%B0%ED%99%94-%EC%98%88%EC%A0%9C%EC%83%9D%EC%82%B0%EC%9E%90-%EC%86%8C%EB%B9%84%EC%9E%90%EB%AC%B8%EC%A0%9C-RW%EB%AC%B8%EC%A0%9C-%EC%8B%9D%EC%82%AC%ED%95%98%EB%8A%94-%EC%B2%A0%ED%95%99%EC%9E%90-%EB%AC%B8%EC%A0%9C><br>