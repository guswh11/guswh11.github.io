파일 시스템
- 자료를 저장하는 파일들의 모음
- 시스템 내의 모든 파일을 정리하고 그에 관한 정보를 제공하는 디렉터리 구조

### 파일 연산(File Operations)
- 파일 생성
    - 파일을 저장할 수 있도록 파일 시스템 내에서 공간을 찾음
    - 새로 생성된 파일에 대한 항목이 디렉터리에 만들어짐
- 파일 쓰기: 파일 이름과 파일에 기록된 정보를 명시하는 시스템 호출 실행
    - 파일의 위치를 찾기 위해 디렉터리를 탐색
    - 시스템은 파일 내의 다음 쓰기가 일어날 위치를 가리키는 쓰기 포인터(write pointer)를 유지
        - 쓰기 포인터는 쓰기가 일어날 때마다 갱신됨
- 파일 읽기: 파일의 이름과 파일이 읽혀 들어갈 메모리 블록의 위치를 명시하는 시스템 호출 실행
    - \
- 파일 안에서의 위치 재설정
- 파일 삭제
- 파일 절단: 파일의 내용은 지우고 그 파일의 속성은 그대로 남기기를 원할 때 사용함

**모든 운영체제는 반드시 한 가지 이상의 파일 구조는 지원해야 한다**
필수 파일 구조: 실행 파일 

### 파일 접근 방법
파일을 구성하는 레코드들이 보조기억장치에 편성되는 방식(파일의 구조)을 의미한다. 

**순차 접근(Sequential Access)**
순차 파일은 레코드를 논리적인 처리 순서에 따라 연속된 물리적 공간으로 기록하는 것을 의미한다.
급여 업무처럼 전체 자료를 처리 대상으로 일괄 처리하는 업무에 사용된다.
대화식 처리보다 일괄 처리에 적합한 구조이다.

장점
파일의 구성이 용이하고, 순차적으로 읽을 수 있으므로 기억공간의 이용 효율이 높다
레코드만 저장하고 북합적인 정보는 저장하지 않으므로 기억공간의 낭비를 방지할 수 있다.
물리적으로 연속된 공간에 저장되므로 접근 속도가 빠르다
어떠한 기억 매체에서도 실현 가능하다
단점
파일에 새로운 레코드를 삽입하거나 삭제하는 경우 파일 전체를 복사한 후 수행해야 하므로 시간이 많이 걸린다.
파일의 특정 레코드를 검색하려면 순차적으로 모든 파일을 비교하면서 검색해야 하므로 검색 효율이 낮다.

**직접 접근(Direct Access)**

파일을 구성하는 레코드를 임의의 물리적 저장공간에 기록하는 것
레코드의 특정 기준으로 키가 할당되며, 해싱 함수(Hashing Function)를 이용하여 키에 대한 보조기억장치의 물리적 상대 레코드 주소를 계산한 후 해당하는 주소에 레코드를 저장한다.
레코드는 해싱 함수에 의해 계산된 물리적 주소를 통해 접근할 수 있다.
임의 접근이 가능한 자기 디스크나 자기 드럼에 사용한다.

장점
직접 접근 기억장치(DASD)의 물리적 주소를 통하여 파일의 각 레코드에 직접 접근하거나 기록할 수 있으며, 접근 및 기록의 순서에는 제약이 없다.
접근 시간이 빠르고 레코드의 삽입, 삭제, 갱신이 용이하다
단점
레코드의 주소 변환 과정이 필요하며, 이 과정으로 인해 시간이 소요된다.
기억공간의 효율이 저하될 수 있다.
기억장치의 물리적 구조에 대한 지식이 필요하고, 프로그래밍 작업이 복잡하다.

색인 순차 파일(Indexed Sequential File)
순차 파일과 직접 파일에서 지원하는 편성 방법이 결합된 형태이다.


색인(인덱스)을 이용한 순차적인 접근 방법을 제공하여 색인 순차 접근 방식(ISAM; Index Sequential Access Method)이라고도 한다.
순차 처리와 랜덤 처리가 모두 가능하도록 레코드들을 키 값 순으로 정렬(sort)시켜 기록하고, 레코드의 키 항목만을 모은 색인을 구성하여 편상하는 방식
각 레코드는 키 값 순으로 논리적으로 저장하고, 시스템은 각 레코드의 실제 주소가 저장된 색인을 관리한다.
레코드를 참조하려면 색인을 탐색한 후 색인이 가리키는 포인터(주소)를 사용하여 참조할 수 있다.
색인 순차 파일은 기본영역, 색인 영역, 오버플로 영역으로 구성된다.
기본 영역(Prime Area) : 실제 레코드가 기록되는 데이터 영역으로, 각 레코드들은 키 값 순으로 저장된다.
색인 영역(Index Area) : 기본 영역에 있는 레코드들의 위치를 찾아가는 색인이 기록되는 영역으로, 트랙 색인 영역, 실린더 색인 영역, 마스터 색인 영역으로 분류한다.
오버 플로 영역(Overflow Area) : 기본 영역에 빈 공간이 없어서 새로운 레코드의 삽입이 불가능할 때를 대비하여 예비로 확보해 둔 영역이다.
장점
순차 처리와 임의 처리가 모두 가능하다.
효율적인 검색이 가능하고 삭제, 삽입, 갱신이 용이하다
단점
색인 영역이나 오버플로 영역을 설정해야 하므로 기억공간이 필요하다.
색인을 이용하여 참조하기 때문에 접근 시간이 직접 파일보다 느리다.

## 디렉터리(Directory)와 디스크 구조 
파일을 저장하는 방법을 의미. 

파티션
- 개별 파일 시스템의 크기를 제한
- 하나의 디스크에 여러 개의 파일 시스템을 사용
- 파일 시스템으로 일부분을 사용하고 나머지는 스왑 공간/raw 디스크 공간 등으로 사용

볼륨(volume)
- 파일 시스템을 포함하고 있는 임의의 개체 
- 장치의 부분 집합, 전체 장치, RAID 집합으로 연결된 다수의 장치 등
- 논리적인 가상 디스크로 취급될 수 있음 
- 여러 개의 운영체제 저장 가능

### 디렉터리 구조
디렉터리: 파일과 다른 디렉터리들의 그룹을 갖고 있는 파일 시스템 내 존재물
- 파일 이름을 해당 디렉터리 항목으로 변환해주는 심벌 테이블 역할 

각 디렉터리에 실행될 수 있는 연산 
- 파일 찾기
- 파일 생성
- 파일 삭제
- 디렉터리 나열
    - 디렉터리에 존재하는 파일을 나열
    - 나열된 각 파일에 대한 디렉터리 항목의 내용을 보여줌
- 파일의 재명명 
- 파일 시스템의 순회(traverse)

#### 1단계 디렉터리(Single-Level Directory)
가장 간단한 디렉터리 구조로, 모든 파일이 디렉터리 밑에 존재한다. 

![single level directory](single-level-directory.png)

장점
- 구현이 쉬움
- 사이즈가 작다면 탐색이 빠름
- 파일에 대한 연산이 쉬움

단점 
- 파일들이 같은 이름을 가질 수 없기 때문에 충돌 확률 증가 
- 같은 종류의 파일 그룹핑 불가 
- 디렉터리가 크다면 탐색 시간이 긺

#### 2단계 디렉터리(Two-Level Directory)
2단계 디렉터리에서 각 사용자는 자신만의 사용자 파일 디렉터리(UFD, User File Directory)를 가진다. 각 UFD에는 한 사용자의 파일만을 저장하며, 시스템에 사용자가 로그인하면 마스터 파일 디렉터리(MFD, Master File Directory)가 탐색되어 UFD를 찾는다. 

![two level directory](two-level-directory.png)

장점
- /user-name/directory-name/ 등으로 이루어진 경로를 부여할 수 있다.
- 각 유저가 같은 디렉터리/파일 이름을 가질 수 있다. 
- 경로 이름과 유저 그룹핑을 통해 파일 탐색이 가능

단점
- 유저 간 파일 공유가 불가능
- 같은 종류의 파일 그룹핑 불가 

#### 트리 구조 디렉터리(Tree-Structured Directory)
다단계 트리 형식의 디렉터리 구조로, 사용자들은 자신의 서브디렉터리(subdirectory)를 만들어 파일을 구성할 수 있다. 모든 파일들은 하나의 루트 디렉터리와 각각의 고유한 경로를 가지며, 디렉터리는 파일과 서브 디렉터리의 집합을 포함한다. 

![tree structured directory](tree-structured-ditrectory.png)

사용자는 자신의 하위디렉터리를 통해 주제별, 정보 유형별로 자유롭게 파일들을 구성할 수 있다. 

장점
- 각 파일들은 고유한 경로 이름을 가진다. 
- 이름 간 충돌이 적기 때문에 확장성이 높다. 
- 절대 경로명과 상대 경로명을 모두 사용하기 때문에, 탐색이 쉽다. 
    - 절대 경로명: 루트-파일까지의 경로를 명시
    - 상대 경로명: 현재 디렉터리를 기준으로 목표 파일까지의 경로를 명시 

단점 
- 파일들이 중복 저장될 수 있다. 
- 파일을 공유할 수 없다. 
- 디렉터리의 삭제가 비효율적일 수 있다. 

#### 비순환 그래프 디렉터리(Acyclic-Graph Directory)
사이클이 없는 그래프 형태로, 디렉터리들은 서브디렉터리들과 파일들을 공유할 수 있다(동일한 파일이나 서브디렉터리가 서로 다른 디렉터리에 있을 수 있다). 각 파일은 여러 개의 절대 경로명을 가질 수 있으며, 파일 이름이 다르더라도 같은 파일을 가리킬 수 있다. 

![acyclic graph directory](acyclic-graph-directory.png)

구현 방법
- 링크(link) 생성
    - 다른 파일이나 서브디렉터리를 가리키는 포인터를 유지 
- 파일을 공유하는 디렉터리들이 공유 파일에 대한 모든 정보를 복사해서 가지고 있는다. 

장점
- 파일 공유가 가능하다
- 파일 탐색이 쉽다. 

단점 
- 각 파일을 한 번씩만 순회하기가 어렵다. 
- 파일과 디렉터리 삭제가 복잡하다. 

#### 일반 그래프 디렉터리(General Graph Directory)
디렉터리 간 사이클이 허용된다. 

![general graph directory](general-graph-directory.png)

장점
- 사이클을 허용한다. 
- 다른 디렉터리 구조보다 유연하다. 

단점
- 가비지 컬렉션이 필요하다. 
    - 디렉터리나 파일이 더 이상 가리켜지지 않더라도 순환으로 인한 자기 참조 때문에 참조계수가 0이 아닐 수 있다. 
    - 시간이 많이 소모된다. 


#### Reference
<https://www.geeksforgeeks.org/structures-of-directory-in-operating-system/><br>
---

## 파일 시스템 마운팅(File-System Mounting)
**마운트(Mount)**: 디스크 등 물리적인 장치를 특정 디렉터리에 연결시켜주는 것 

**마운트 과정**
1. 운영체제는 디바이스 이름과 마운트 포인트(mount point)를 전달받는다. 
    - 마운트 포인트: 파일 시스템을 부착할 수 있는 파일 구조 내의 위치 
2. 운영체제는 디바이스가 유효한 파일 시스템을 포함하는지 검증한다. 
    - 디바이스 드라이버에게 디바이스 디렉터리를 읽도록 요청
    - 읽혀진 디렉터리가 유효한 포맷을 가지고 있는지 검증
3. 지정된 마운트 포인트에 파일 시스템이 마운트되었음을 디렉터리 구조에 기록한다. 

시스템은 파일을 포함하고 있는 디렉터리에 대해서는 
1. 마운트를 허용하지 않거나
2. 마운트 후 마운트된 파일 시스템에만 접근할 수 있게 하고, 기존의 파일들은 언마운트 전까지 안 보이게 한다. 

윈도우의 경우, 부팅 시 모든 디바이스를 자동으로 발견하고 모든 파일 시스템을 마운트한다. 또 PnP(Plug and play, 디바이스를 연결하면 자동으로 설정/플레이 해줌) 기능을 지원해 사용자가 직접 마운팅해주지 않아도 된다.<br>
유닉스의 경우 시스템 구성 파일은 부팅 시 자동 마운팅할 디바이스의 목록과 마운트 포인트를 포함하고 있지만, 이외의 장치들은 수작업으로 마운트되어야 한다. 

## 파일 공유(File Sharing)
### 다수의 사용자의 파일 공유 
다수의 사용자가 파일을 공유하는 시스템은 단일 사용자 시스템보다 더 많은 파일과 디렉터리 속성을 유지해야 한다. 대부분의 시스템은 파일/디렉터리의 **소유자(owner, user)** 와 **그룹(group)** 개념을 사용한다.<br>
소유자: 파일 속성을 변경하거나 접근을 허가하고, 파일에 대해 가장 많은 제어 권한을 가지는 사용자<br>
그룹: 파일에 대한 접근을 공유할 수 있는 사용자들의 부분집합 

### 원격 파일 시스템(Remote File Systems)
네트워크의 발전으로 인한 파일 공유 방법 변화
- FTP 프로그램을 통한 기계간 파일 직접 전송 방식
- 분산 파일 시스템(Distributed File System, DFS) 사용
    - 로컬 기계에서 원격 디렉터리에 접근 
- WWW 사용 
    - 브라우저를 통해 파일을 전송 
    - 파일 전송을 위해 FTP의 wrapper 형식 사용 

#### 클라이언트 서버 모델(The Client-Server Model)
서버: 파일을 가지고 있는 컴퓨터
클라이언트: 파일에 접근하기를 원하는 컴퓨터 

- 서버는 클라이언트에게 자원 사용이 가능함을 명시 
- 어느 자원(파일)이 어느 클라이언트인지 명시
- 구현에 따라 서버는 여러 클라이언트에게 서비스 제공 가능, 클라이언트도 여러 서버 사용 가능
- 클라이언트의 식별자는 도용이나 모방될 수 있으므로, 보안 인증이 필요하다. 

