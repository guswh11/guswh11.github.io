# 파일 시스템 구현
## 파일 시스템 구조
파일 시스템은 여러 층으로 이루어져 있다. 계층 구조를 통해 하드 디스크, 시디롬 드라이브, 플래시 메모리 등 다양한 형태의 저장 장치를 지원할 수 있고, 하나의 시스템에 여러 개의 파일 시스템을 사용하는 것이 가능해진다.

계층 구조의 장점
- 코드의 중복 최소화
    - I/O제어, 기본 파일 시스템 코드 등은 여러 파일 시스템에 의해 사용될 수 있음

계층 구조의 단점
- 더 많은 운영체제 오버헤드 

![file system architecture](file-system-architecture.png)

입출력 제어(I/O control) 층: 메모리와 디스크 시스템간의 정보 전송을 담당
- 장치 드라이버(device driver)와 인터럽트 핸들러로 이루어짐
- 장치 드라이버: 특정 블록을 검색하는 등의 고수준의 명령을 입출력장치를 시스템의 다른 부분에 접속시키는 저수준의 명령으로 변환
    - 입출력 제어기 메모리의 특별한 위치에 특정 비트 패턴을 설정해 장치 내 어떤 위치에 무슨 작업을 해야 할지 알림

기본 파일 시스템(basic file system) 층: 적절한 장치 드라이버에게 디스크 상의 물리 블록을 읽고 쓰도록 명령을 내리는 층
- 다양한 파일 시스템, 디렉터리 및 데이터 블록을 저장하는 메모리 버퍼와 캐시를 관리함 
    - 버퍼 내 블록은 디스크 블록의 전송이 일어나기 전에 할당된다. 
    - 버퍼가 가득 차면, 버퍼 관리자는 요청된 입출력이 완료될 수 있도록 버퍼 공간을 확보해야 한다. 

파일-구성 모듈(file-organization module) 층: 파일의 논리 블록 주소를 물리 블록 주소로 변환하며, 가용 공간을 관리한다. 
- 각 파일의 논리 블록은 0(또는 1)부터 N까지 번호가 매겨진다. 
- 실제로 데이터를 저장하고 있는 물리 블록은 논리 번호와 일치하지 않기 때문에 각 블록의 위치를 알아내기 위해서 변환이 필요하다. 
- 가용 공간 관리자는 할당되지 않은 블록을 추적하고, 요청이 있을 때 파일-구성 모듈에게 블록을 공급한다. 

논리 파일 시스템(logical file system) 층: 메타데이터 정보를 관리한다. 
- 메타데이터는 실제 파일의 내용을 제외한 모든 파일 시스템 구조를 포함
- 디렉터리 구조 관리, 심벌릭 이름 제공, 파일-구성 모듈이 필요로 하는 정보 제공
- 파일 제어 블록(File Control Block, PCB)를 통해 파일 구조 유지
    - 소유, 허가, 파일 내용의 위치 등 파일에 관한 정보 포함

## 파일 시스템 구현 
- 부트 제어 블록(boot control block): 시스템이 볼륨으로부터 운영체제를 부트시키기 위해 필요한 정보를 가지고 있다. 
    - 디스크가 운영체제를 가지고 있지 않다면 비어 있다. 
- 볼륨 제어 블록(volume control block): 상세한 볼륨 정보를 저장한다. 
    - 볼륨(또는 파티션)의 블록 수, 블록의 크기, 가용 블록 수와 포인터, 가용 FCB 수와 포인터 등
- 디렉터리 구조는 파일 시스템마다 존재하며 파일을 조직하는 데 사용된다. 
- FCB: 파일별로 존재하며, 자세한 파일 정보를 가지고 있다.
    - 디렉터리 항목과의 연결을 위해 고유한 식별 번호를 가진다. 
    ![FCB](typical-fcb.jpg)

메모리 내 정보는 <u>파일 시스템 관리와 캐싱</u>을 위해 사용된다. 아래 정보들은 마운트 시점에 적재되고, 파일 시스템 동작 중에 갱신되며, 마운트 해제 시 제거된다. 
- 메모리 내 마운트 테이블
    - 각 마운트 된 볼륨 정보를 저장 
- 메모리 내 디렉터리 구조 캐시
    - 최근 접근된 디렉터리의 디렉터리 정보를 유지함 
    - 볼륨이 마운트된 디렉터리의 경우, 볼륨 테이블에 대한 포인터를 포함
- 범 시스템 열린 파일 테이블(system wide open file table)
    - 모든 열린 파일의 FCB 복사본을 가짐
- 프로세스별 열린 파일 테이블(per-process open file table)
    - 범 시스템 오픈 파일 테이블 내의 해당 항목에 대한 포인터를 포함 
- 파일 시스템 블록
    - 파일 시스템이 디스크로부터 읽혀지거나 써질 때 저장됨

### 파일 생성, open(), close()

---

## 디스크, 파티션, 볼륨의 차이 
**디스크(Disk)**
시스템에 장착되어 있는 물리적인 저장장치를 의미한다. 

**파티션(Partition)**
물리적인 디스크를 여러 독립적인 공간으로 구분해 놓은 것을 의미한다. 

![disk and partition](disk-partition.png)

파티션은 하나의 물리적인 저장 장치(디스크)를 여러 개의 독립적인 저장 장치처럼 사용할 수 있게 구분해준다.

각 파티션은 미가공 파티션과 가공 파티션으로 나눌 수 있다. 
- 미가공(raw) 파티션: 파일 시스템을 포함하지 않음
    - 어떤 파일 시스템도 적합하지 않은 곳에 사용됨<br>
    ex) UNIX 스왑 공간 
- 가공(cooked) 파티션: 파일 시스템을 포함함

**볼륨(Volume)**
볼륨은 단일 파일 시스템을 사용해 액세스할 수 있는 저장 공간을 의미한다. 

일반적으로 디스크를 파티션으로 구분하고, <u>각 파티션을 파일 시스템으로 포맷해 볼륨을 구성</u>한다. 볼륨은 여러 디스크의 여러 파티션에 걸쳐있을 수 있다. 

![partition and volume](partition-volume.png)

---

### 가상 파일 시스템(Virtual File System, VFS)
**가상 파일 시스템**은 실제 파일 시스템 위의 추상 계층으로, 클라이언트 응용 프로그램이 여러 파일 시스템에 같은 방법으로 접근할 수 있게 하는 것이다. 

현대의 운영체제는 동시에 여러 타입의 파일 시스템을 지원하기 위해 VFS를 사용한다. 

VFS는 주로 객체 지향 방식의 오버로딩 개념을 통해 구현되며, 다음과 같이 세 가지 계층으로 구성된다. 

![VFS](virtual-file-system.png)

파일 시스템 추상화의 장점
- 동일한 방법으로 접근 가능
- 파일 시스템간의 이식성이 좋음
- 새로운 파일 시스템이 추가되더라도 설계를 변경할 필요 없음 

--- 

## 디렉터리 구현 방법
### 선형 리스트(Linear List)
디렉터리를 구현하는 가장 간단한 방법으로, 파일 이름과 데이터 블록을 가리키는 포인터들의 선형 리스트를 사용한다. 

파일 생성: 디렉터리를 탐색해 같은 이름을 가진 파일이 없다는 것을 확인 후, 디렉터리의 끝부분에 새로운 항목을 추가한다.<br> 
파일 삭제: 디렉터리에서 이름을 찾아 해당 파일에 할당된 공간을 방출한다. 

파일 삭제 후 해당 항목을 미사용으로 표시하거나, 디렉터리 항목의 가용 리스트에 연결해 항목을 재사용할 수 있다. 

장점 
- 구현이 쉽다. 

단점 
- 파일을 찾기 위해 선형 탐색을 해야 한다. 
    - 실행 시간이 길다. 
    - 정렬된 리스트는 이진 탐색이 가능해 평균 탐색시간이 줄지만, 리스트가 정렬 상태를 유지하려면 파일의 생성과 삭제가 복잡해진다. 

### 해시 테이블(Hash Table)
선형 리스트에 디렉터리 항목들을 저장하고 해싱도 함께 사용하는 방법이다. 